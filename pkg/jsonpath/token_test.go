package jsonpath

import (
	"fmt"
	"testing"
)

func TestTokenizer(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected []TokenInfo
	}{
		{
			name:  "Root",
			input: "$",
			expected: []TokenInfo{
				{Token: ROOT, Line: 1, Column: 0, Literal: "", Len: 1},
			},
		},
		{
			name:  "Child",
			input: "$.store.book",
			expected: []TokenInfo{
				{Token: ROOT, Line: 1, Column: 0, Literal: "", Len: 1},
				{Token: CHILD, Line: 1, Column: 1, Literal: "", Len: 1},
				{Token: STRING_LITERAL, Line: 1, Column: 2, Literal: "store", Len: 5},
				{Token: CHILD, Line: 1, Column: 7, Literal: "", Len: 1},
				{Token: STRING_LITERAL, Line: 1, Column: 8, Literal: "book", Len: 4},
			},
		},
		{
			name:  "Wildcard",
			input: "$.*",
			expected: []TokenInfo{
				{Token: ROOT, Line: 1, Column: 0, Literal: "", Len: 1},
				{Token: CHILD, Line: 1, Column: 1, Literal: "", Len: 1},
				{Token: WILDCARD, Line: 1, Column: 2, Literal: "", Len: 1},
			},
		},
		{
			name:  "Recursive",
			input: "$..author",
			expected: []TokenInfo{
				{Token: ROOT, Line: 1, Column: 0, Literal: "", Len: 1},
				{Token: RECURSIVE, Line: 1, Column: 1, Literal: "", Len: 2},
				{Token: STRING_LITERAL, Line: 1, Column: 3, Literal: "author", Len: 6},
			},
		},
		{
			name:  "Union",
			input: "$..book[0,1]",
			expected: []TokenInfo{
				{Token: ROOT, Line: 1, Column: 0, Literal: "", Len: 1},
				{Token: RECURSIVE, Line: 1, Column: 1, Literal: "", Len: 2},
				{Token: STRING_LITERAL, Line: 1, Column: 3, Literal: "book", Len: 4},
				{Token: BRACKET_LEFT, Line: 1, Column: 7, Literal: "", Len: 1},
				{Token: NUMBER, Line: 1, Column: 8, Literal: "0", Len: 1},
				{Token: UNION, Line: 1, Column: 9, Literal: "", Len: 1},
				{Token: NUMBER, Line: 1, Column: 10, Literal: "1", Len: 1},
				{Token: BRACKET_RIGHT, Line: 1, Column: 11, Literal: "", Len: 1},
			},
		},
		{
			name:  "Slice",
			input: "$..book[0:2]",
			expected: []TokenInfo{
				{Token: ROOT, Line: 1, Column: 0, Literal: "", Len: 1},
				{Token: RECURSIVE, Line: 1, Column: 1, Literal: "", Len: 2},
				{Token: STRING_LITERAL, Line: 1, Column: 3, Literal: "book", Len: 4},
				{Token: BRACKET_LEFT, Line: 1, Column: 7, Literal: "", Len: 1},
				{Token: NUMBER, Line: 1, Column: 8, Literal: "0", Len: 1},
				{Token: ARRAY_SLICE, Line: 1, Column: 9, Literal: "", Len: 1},
				{Token: NUMBER, Line: 1, Column: 10, Literal: "2", Len: 1},
				{Token: BRACKET_RIGHT, Line: 1, Column: 11, Literal: "", Len: 1},
			},
		},
		{
			name:  "Filter",
			input: "$.store.book[?(@.price < 10)]",
			expected: []TokenInfo{
				{Token: ROOT, Line: 1, Column: 0, Literal: "", Len: 1},
				{Token: CHILD, Line: 1, Column: 1, Literal: "", Len: 1},
				{Token: STRING_LITERAL, Line: 1, Column: 2, Literal: "store", Len: 5},
				{Token: CHILD, Line: 1, Column: 7, Literal: "", Len: 1},
				{Token: STRING_LITERAL, Line: 1, Column: 8, Literal: "book", Len: 4},
				{Token: BRACKET_LEFT, Line: 1, Column: 12, Literal: "", Len: 1},
				{Token: FILTER, Line: 1, Column: 13, Literal: "", Len: 1},
				{Token: PAREN_LEFT, Line: 1, Column: 14, Literal: "", Len: 1},
				{Token: CURRENT, Line: 1, Column: 15, Literal: "", Len: 1},
				{Token: CHILD, Line: 1, Column: 16, Literal: "", Len: 1},
				{Token: STRING_LITERAL, Line: 1, Column: 17, Literal: "price", Len: 5},
				{Token: LT, Line: 1, Column: 23, Literal: "", Len: 1},
				{Token: NUMBER, Line: 1, Column: 25, Literal: "10", Len: 2},
				{Token: PAREN_RIGHT, Line: 1, Column: 27, Literal: "", Len: 1},
				{Token: BRACKET_RIGHT, Line: 1, Column: 28, Literal: "", Len: 1},
			},
		},
		{
			name:  "Filter equality",
			input: "$[?(@.child=='x')]",
			expected: []TokenInfo{
				{Token: ROOT, Line: 1, Column: 0, Literal: "", Len: 1},
				{Token: BRACKET_LEFT, Line: 1, Column: 1, Literal: "", Len: 1},
				{Token: FILTER, Line: 1, Column: 2, Literal: "", Len: 1},
				{Token: PAREN_LEFT, Line: 1, Column: 3, Literal: "", Len: 1},
				{Token: CURRENT, Line: 1, Column: 4, Literal: "", Len: 1},
				{Token: CHILD, Line: 1, Column: 5, Literal: "", Len: 1},
				{Token: STRING_LITERAL, Line: 1, Column: 6, Literal: "child", Len: 5},
				{Token: EQ, Line: 1, Column: 11, Literal: "", Len: 2},
				{Token: STRING, Line: 1, Column: 13, Literal: "x", Len: 1},
				{Token: PAREN_RIGHT, Line: 1, Column: 16, Literal: "", Len: 1},
				{Token: BRACKET_RIGHT, Line: 1, Column: 17, Literal: "", Len: 1},
			},
		},
		{
			name:  "Filter inequality",
			input: "$[?(@.child!='x')]",
			expected: []TokenInfo{
				{Token: ROOT, Line: 1, Column: 0, Literal: "", Len: 1},
				{Token: BRACKET_LEFT, Line: 1, Column: 1, Literal: "", Len: 1},
				{Token: FILTER, Line: 1, Column: 2, Literal: "", Len: 1},
				{Token: PAREN_LEFT, Line: 1, Column: 3, Literal: "", Len: 1},
				{Token: CURRENT, Line: 1, Column: 4, Literal: "", Len: 1},
				{Token: CHILD, Line: 1, Column: 5, Literal: "", Len: 1},
				{Token: STRING_LITERAL, Line: 1, Column: 6, Literal: "child", Len: 5},
				{Token: NE, Line: 1, Column: 11, Literal: "", Len: 2},
				{Token: STRING, Line: 1, Column: 13, Literal: "x", Len: 1},
				{Token: PAREN_RIGHT, Line: 1, Column: 16, Literal: "", Len: 1},
				{Token: BRACKET_RIGHT, Line: 1, Column: 17, Literal: "", Len: 1},
			},
		},
		{
			name:  "Filter greater than",
			input: "$[?(@.child>1)]",
			expected: []TokenInfo{
				{Token: ROOT, Line: 1, Column: 0, Literal: "", Len: 1},
				{Token: BRACKET_LEFT, Line: 1, Column: 1, Literal: "", Len: 1},
				{Token: FILTER, Line: 1, Column: 2, Literal: "", Len: 1},
				{Token: PAREN_LEFT, Line: 1, Column: 3, Literal: "", Len: 1},
				{Token: CURRENT, Line: 1, Column: 4, Literal: "", Len: 1},
				{Token: CHILD, Line: 1, Column: 5, Literal: "", Len: 1},
				{Token: STRING_LITERAL, Line: 1, Column: 6, Literal: "child", Len: 5},
				{Token: GT, Line: 1, Column: 11, Literal: "", Len: 1},
				{Token: NUMBER, Line: 1, Column: 12, Literal: "1", Len: 1},
				{Token: PAREN_RIGHT, Line: 1, Column: 13, Literal: "", Len: 1},
				{Token: BRACKET_RIGHT, Line: 1, Column: 14, Literal: "", Len: 1},
			},
		},
		{
			name:  "Filter greater than or equal",
			input: "$[?(@.child>=1)]",
			expected: []TokenInfo{
				{Token: ROOT, Line: 1, Column: 0, Literal: "", Len: 1},
				{Token: BRACKET_LEFT, Line: 1, Column: 1, Literal: "", Len: 1},
				{Token: FILTER, Line: 1, Column: 2, Literal: "", Len: 1},
				{Token: PAREN_LEFT, Line: 1, Column: 3, Literal: "", Len: 1},
				{Token: CURRENT, Line: 1, Column: 4, Literal: "", Len: 1},
				{Token: CHILD, Line: 1, Column: 5, Literal: "", Len: 1},
				{Token: STRING_LITERAL, Line: 1, Column: 6, Literal: "child", Len: 5},
				{Token: GE, Line: 1, Column: 11, Literal: "", Len: 2},
				{Token: NUMBER, Line: 1, Column: 13, Literal: "1", Len: 1},
				{Token: PAREN_RIGHT, Line: 1, Column: 14, Literal: "", Len: 1},
				{Token: BRACKET_RIGHT, Line: 1, Column: 15, Literal: "", Len: 1},
			},
		},
		{
			name:  "Filter less than",
			input: "$[?(@.child<1)]",
			expected: []TokenInfo{
				{Token: ROOT, Line: 1, Column: 0, Literal: "", Len: 1},
				{Token: BRACKET_LEFT, Line: 1, Column: 1, Literal: "", Len: 1},
				{Token: FILTER, Line: 1, Column: 2, Literal: "", Len: 1},
				{Token: PAREN_LEFT, Line: 1, Column: 3, Literal: "", Len: 1},
				{Token: CURRENT, Line: 1, Column: 4, Literal: "", Len: 1},
				{Token: CHILD, Line: 1, Column: 5, Literal: "", Len: 1},
				{Token: STRING_LITERAL, Line: 1, Column: 6, Literal: "child", Len: 5},
				{Token: LT, Line: 1, Column: 11, Literal: "", Len: 1},
				{Token: NUMBER, Line: 1, Column: 12, Literal: "1", Len: 1},
				{Token: PAREN_RIGHT, Line: 1, Column: 13, Literal: "", Len: 1},
				{Token: BRACKET_RIGHT, Line: 1, Column: 14, Literal: "", Len: 1},
			},
		},
		{
			name:  "Filter less than or equal",
			input: "$[?(@.child<=1)]",
			expected: []TokenInfo{
				{Token: ROOT, Line: 1, Column: 0, Literal: "", Len: 1},
				{Token: BRACKET_LEFT, Line: 1, Column: 1, Literal: "", Len: 1},
				{Token: FILTER, Line: 1, Column: 2, Literal: "", Len: 1},
				{Token: PAREN_LEFT, Line: 1, Column: 3, Literal: "", Len: 1},
				{Token: CURRENT, Line: 1, Column: 4, Literal: "", Len: 1},
				{Token: CHILD, Line: 1, Column: 5, Literal: "", Len: 1},
				{Token: STRING_LITERAL, Line: 1, Column: 6, Literal: "child", Len: 5},
				{Token: LE, Line: 1, Column: 11, Literal: "", Len: 2},
				{Token: NUMBER, Line: 1, Column: 13, Literal: "1", Len: 1},
				{Token: PAREN_RIGHT, Line: 1, Column: 14, Literal: "", Len: 1},
				{Token: BRACKET_RIGHT, Line: 1, Column: 15, Literal: "", Len: 1},
			},
		},
		{
			name:  "Filter logical AND",
			input: "$[?(@.child&&@.other)]",
			expected: []TokenInfo{
				{Token: ROOT, Line: 1, Column: 0, Literal: "", Len: 1},
				{Token: BRACKET_LEFT, Line: 1, Column: 1, Literal: "", Len: 1},
				{Token: FILTER, Line: 1, Column: 2, Literal: "", Len: 1},
				{Token: PAREN_LEFT, Line: 1, Column: 3, Literal: "", Len: 1},
				{Token: CURRENT, Line: 1, Column: 4, Literal: "", Len: 1},
				{Token: CHILD, Line: 1, Column: 5, Literal: "", Len: 1},
				{Token: STRING_LITERAL, Line: 1, Column: 6, Literal: "child", Len: 5},
				{Token: AND, Line: 1, Column: 11, Literal: "", Len: 2},
				{Token: CURRENT, Line: 1, Column: 13, Literal: "", Len: 1},
				{Token: CHILD, Line: 1, Column: 14, Literal: "", Len: 1},
				{Token: STRING_LITERAL, Line: 1, Column: 15, Literal: "other", Len: 5},
				{Token: PAREN_RIGHT, Line: 1, Column: 20, Literal: "", Len: 1},
				{Token: BRACKET_RIGHT, Line: 1, Column: 21, Literal: "", Len: 1},
			},
		},
		{
			name:  "Filter logical OR",
			input: "$[?(@.child||@.other)]",
			expected: []TokenInfo{
				{Token: ROOT, Line: 1, Column: 0, Literal: "", Len: 1},
				{Token: BRACKET_LEFT, Line: 1, Column: 1, Literal: "", Len: 1},
				{Token: FILTER, Line: 1, Column: 2, Literal: "", Len: 1},
				{Token: PAREN_LEFT, Line: 1, Column: 3, Literal: "", Len: 1},
				{Token: CURRENT, Line: 1, Column: 4, Literal: "", Len: 1},
				{Token: CHILD, Line: 1, Column: 5, Literal: "", Len: 1},
				{Token: STRING_LITERAL, Line: 1, Column: 6, Literal: "child", Len: 5},
				{Token: OR, Line: 1, Column: 11, Literal: "", Len: 2},
				{Token: CURRENT, Line: 1, Column: 13, Literal: "", Len: 1},
				{Token: CHILD, Line: 1, Column: 14, Literal: "", Len: 1},
				{Token: STRING_LITERAL, Line: 1, Column: 15, Literal: "other", Len: 5},
				{Token: PAREN_RIGHT, Line: 1, Column: 20, Literal: "", Len: 1},
				{Token: BRACKET_RIGHT, Line: 1, Column: 21, Literal: "", Len: 1},
			},
		},
		{
			name:  "Filter logical NOT",
			input: "$[?(!@.child)]",
			expected: []TokenInfo{
				{Token: ROOT, Line: 1, Column: 0, Literal: "", Len: 1},
				{Token: BRACKET_LEFT, Line: 1, Column: 1, Literal: "", Len: 1},
				{Token: FILTER, Line: 1, Column: 2, Literal: "", Len: 1},
				{Token: PAREN_LEFT, Line: 1, Column: 3, Literal: "", Len: 1},
				{Token: NOT, Line: 1, Column: 4, Literal: "", Len: 1},
				{Token: CURRENT, Line: 1, Column: 5, Literal: "", Len: 1},
				{Token: CHILD, Line: 1, Column: 6, Literal: "", Len: 1},
				{Token: STRING_LITERAL, Line: 1, Column: 7, Literal: "child", Len: 5},
				{Token: PAREN_RIGHT, Line: 1, Column: 12, Literal: "", Len: 1},
				{Token: BRACKET_RIGHT, Line: 1, Column: 13, Literal: "", Len: 1},
			},
		},
		//{
		//	name:  "Filter regular expression (illegal right now)",
		//	input: "$[?(@.child=~/.*/)]",
		//	expected: []TokenInfo{
		//		{Token: ROOT, Line: 1, Column: 0, Literal: "", Len: 1},
		//		{Token: FILTER, Line: 1, Column: 1, Literal: "", Len: 2},
		//		{Token: PAREN_LEFT, Line: 1, Column: 3, Literal: "", Len: 1},
		//		{Token: CURRENT, Line: 1, Column: 4, Literal: "", Len: 1},
		//		{Token: CHILD, Line: 1, Column: 5, Literal: "", Len: 1},
		//		{Token: STRING_LITERAL, Line: 1, Column: 6, Literal: "child", Len: 5},
		//		{Token: MATCHES, Line: 1, Column: 11, Literal: "", Len: 2},
		//		{Token: ILLEGAL, Line: 1, Column: 13, Literal: "", Len: 1},
		//		{Token: PAREN_RIGHT, Line: 1, Column: 17, Literal: "", Len: 1},
		//		{Token: BRACKET_RIGHT, Line: 1, Column: 18, Literal: "", Len: 1},
		//	},
		//},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			tokenizer := NewTokenizer(test.input)
			tokens := tokenizer.Tokenize()

			if len(tokens) != len(test.expected) {
				msg := tokenizer.ErrorTokenString(tokens[0], fmt.Sprintf("Expected %d tokens, got %d", len(test.expected), len(tokens)))
				t.Error(msg)
			}

			for i, expectedToken := range test.expected {
				actualToken := tokens[i]
				if actualToken != expectedToken {
					msg := tokenizer.ErrorString(actualToken, fmt.Sprintf("Expected token %+v, got %+v", expectedToken, actualToken))
					t.Error(msg)
				}
			}
		})
	}
}

func TestTokenizer_NoPanic(t *testing.T) {
	testCases := []struct {
		name string
		path string
	}{
		{name: "identity", path: ""},
		{name: "root", path: "$"},
		{name: "unmatched closing parenthesis", path: ")"},
		{name: "unmatched closing square bracket", path: "]"},
		{name: "dot child", path: "$.child"},
		{name: "dot child with implicit root", path: ".child"},
		{name: "undotted child with implicit root", path: "child"},
		{name: "dot child with no name", path: "$."},
		{name: "dot child with missing dot", path: "$a"},
		{name: "dot child with trailing dot", path: "$.child."},
		{name: "dot child of dot child", path: "$.child1.child2"},
		{name: "dot child with array subscript", path: "$.child[*]"},
		{name: "dot child with malformed array subscript", path: "$.child[1:2:3:4]"},
		{name: "dot child with array subscript with zero step", path: "$.child[1:2:0]"},
		{name: "dot child with non-integer array subscript", path: "$.child[1:2:a]"},
		{name: "dot child with unclosed array subscript", path: "$.child[*"},
		{name: "dot child with missing array subscript", path: "$.child[]"},
		{name: "dot child with embedded space", path: "$.child more"},
		{name: "bracket child", path: "$['child']"},
		{name: "bracket child with double quotes", path: `$["child"]`},
		{name: "bracket child with unmatched quotes", path: `$["child']`},
		{name: "bracket child with empty name", path: "$['']"},
		{name: "bracket child of bracket child", path: "$['child1']['child2']"},
		{name: "double quoted bracket child of bracket child", path: `$['child1']["child2"]`},
		{name: "bracket child union", path: "$['child','child2']"},
		{name: "bracket child union with whitespace", path: "$[ 'child' , 'child2' ]"},
		{name: "bracket child union with mixed quotes", path: `$[ 'child' , "child2" ]`},
		{name: "bracket child quoted union literal", path: "$[',']"},
		{name: "bracket child with array subscript", path: "$['child'][*]"},
		{name: "bracket child with malformed array subscript", path: "$['child'][1:2:3:4]"},
		{name: "bracket child with non-integer array subscript", path: "$['child'][1:2:a]"},
		{name: "bracket child with unclosed array subscript", path: "$['child'][*"},
		{name: "bracket child with missing array subscript", path: "$['child'][]"},
		{name: "bracket child followed by space", path: "$['child'] "},
		{name: "bracket dotted child", path: "$['child1.child2']"},
		{name: "bracket child with array subscript", path: "$['child'][*]"},
		{name: "property name dot child", path: "$.child~"},
		{name: "property name dot child with implicit root", path: ".child~"},
		{name: "property name undotted child with implicit root", path: "child~"},
		{name: "property name dot child with no name", path: "$.~"},
		{name: "property name dot child with missing dot", path: "$a~"},
		{name: "property name dot child with trailing chars", path: "$.child~.test"},
		{name: "property name undotted child with trailing chars", path: "child~.test"},
		{name: "property name dot child with trailing dot", path: "$.child.~"},
		{name: "property name dot child of dot child", path: "$.child1.child2~"},
		{name: "property name dot child with wildcard array subscript", path: "$.child[*]~"},
		{name: "property name dot child with an array subscript", path: "$.child[0]~"},
		{name: "property name dot child with array subscript with zero step", path: "$.child[1:2:0]~"},
		{name: "property name dot child with non-integer array subscript", path: "$.child[1:2:a]~"},
		{name: "property name dot child with unclosed array subscript", path: "$.child[*~"},
		{name: "property name dot child with missing array subscript", path: "$.child[]~"},
		{name: "property name dot child with embedded space", path: "$.child more~"},
		{name: "property name bracket child", path: "$['child']~"},
		{name: "property name bracket child with double quotes", path: `$["child"]~`},
		{name: "property name bracket child with unmatched quotes", path: `$["child']~`},
		{name: "property name bracket child with empty name", path: "$['']~"},
		{name: "property name bracket child of bracket child", path: "$['child1']['child2']~"},
		{name: "property name double quoted bracket child of bracket child", path: `$['child1']["child2"]~`},
		{name: "property name bracket child union", path: "$['child','child2']~"},
		{name: "property name bracket child union with whitespace", path: "$[ 'child' , 'child2' ]~"},
		{name: "property name bracket child union with mixed quotes", path: `$[ 'child' , "child2" ]~`},
		{name: "property name bracket child quoted union literal", path: "$[',']~"},
		{name: "property name bracket child with wildcard array subscript", path: "$['child'][*]~"},
		{name: "property name bracket child with wildcard array subscript and trailing chars", path: "$['child'][*]~.child"},
		{name: "property name bracket child with ~ in name", path: "$['child~']~"},
		{name: "bracket child with array subscript", path: "$['child'][1]~"},
		{name: "property name bracket child with non-integer array subscript", path: "$['child'][1:2:a]~"},
		{name: "property name bracket child with unclosed array subscript", path: "$['child'][*~"},
		{name: "property name bracket child with missing array subscript", path: "$['child'][]~"},
		{name: "property name bracket child separated a  by space", path: "$['child'] ~"},
		{name: "property name bracket child followed by space", path: "$['child']~ "},
		{name: "property name bracket dotted child", path: "$['child1.child2']~"},
		{name: "array union", path: "$[0,1]"},
		{name: "array union with whitespace", path: "$[ 0 , 1 ]"},
		{name: "bracket child with malformed array subscript", path: "$['child'][1:2:3:4]"},
		{name: "bracket child with malformed array subscript in union", path: "$['child'][0,1:2:3:4]"},
		{name: "bracket child with non-integer array subscript", path: "$['child'][1:2:a]"},
		{name: "bracket child of dot child", path: "$.child1['child2']"},
		{name: "array slice of root", path: "$[1:3]"},
		{name: "dot child of bracket child", path: "$['child1'].child2"},
		{name: "recursive descent", path: "$..child"},
		{name: "recursive descent of dot child", path: "$.child1..child2"},
		{name: "recursive descent of bracket child", path: "$['child1']..child2"},
		{name: "repeated recursive descent", path: "$..child1..child2"},
		{name: "recursive descent with dot child", path: "$..child1.child2"},
		{name: "recursive descent with bracket child", path: "$..child1['child2']"},
		{name: "recursive descent with missing name", path: "$.."},
		{name: "recursive descent with array access", path: "$..[0]"},
		{name: "recursive descent with filter", path: "$..[?(@.child)]"},
		{name: "recursive descent with bracket child", path: "$..['child']"},
		{name: "recursive descent with double quoted bracket child", path: `$..["child"]`},
		{name: "wildcarded children", path: "$.*"},
		{name: "simple filter", path: "$[?(@.child)]"},
		{name: "simple filter with leading whitespace", path: "$[?( @.child)]"},
		{name: "simple filter with trailing whitespace", path: "$[?( @.child )]"},
		{name: "simple filter with bracket", path: "$[?((@.child))]"},
		{name: "simple filter with bracket with extra whitespace", path: "$[?( ( @.child ) )]"},
		{name: "simple filter with more complex subpath", path: "$[?((@.child[0]))]"},
		{name: "missing filter ", path: "$[?()]"},
		{name: "unclosed filter", path: "$[?("},
		{name: "filter with missing operator", path: "$[?(@.child @.other)]"},
		{name: "filter with malformed term", path: "$[?([)]"},
		{name: "filter with misplaced open bracket", path: "$[?(@.child ()]"},
		{name: "simple negative filter", path: "$[?(!@.child)]"},
		{name: "misplaced filter negation", path: "$[?(@.child !@.other)]"},
		{name: "simple negative filter with extra whitespace", path: "$[?( ! @.child)]"},
		{name: "simple filter with root expression", path: "$[?($.child)]"},
		{name: "filter integer equality, literal on the right", path: "$[?(@.child==1)]"},
		{name: "filter string equality, literal on the right", path: "$[?(@.child=='x')]"},
		{name: "filter string equality with apparent boolean", path: `$[?(@.child=="true")]`},
		{name: "filter string equality with apparent null", path: `$[?(@.child=="null")]`},
		{name: "filter string equality, double-quoted literal on the right", path: `$[?(@.child=="x")]`},
		{name: "filter integer equality with invalid literal", path: "$[?(@.child==-)]"},
		{name: "filter integer equality with integer literal which is too large", path: "$[?(@.child==9223372036854775808)]"},
		{name: "filter integer equality with invalid float literal", path: "$[?(@.child==1.2.3)]"},
		{name: "filter integer equality with invalid string literal", path: "$[?(@.child=='x)]"},
		{name: "filter integer equality, literal on the left", path: "$[?(1==@.child)]"},
		{name: "filter float equality, literal on the left", path: "$[?(1.5==@.child)]"},
		{name: "filter fractional float equality, literal on the left", path: "$[?(-1.5e-1==@.child)]"},
		{name: "filter fractional float equality, literal on the right", path: "$[?(@.child== -1.5e-1 )]"},
		{name: "filter boolean true equality, literal on the right", path: "$[?(@.child== true )]"},
		{name: "filter boolean false equality, literal on the right", path: "$[?(@.child==false)]"},
		{name: "filter boolean true equality, literal on the left", path: "$[?(true==@.child)]"},
		{name: "filter boolean false equality, literal on the left", path: "$[?( false ==@.child)]"},
		{name: "filter null equality, literal on the right", path: "$[?(@.child==null)]"},
		{name: "filter null true equality, literal on the left", path: "$[?(null==@.child)]"},
		{name: "filter equality with missing left hand value", path: "$[?(==@.child)]"},
		{name: "filter equality with missing left hand value inside bracket", path: "$[?((==@.child))]"},
		{name: "filter equality with missing right hand value", path: "$[?(@.child==)]"},
		{name: "filter integer equality, root path on the right", path: "$[?(@.child==$.x)]"},
		{name: "filter integer equality, root path on the left", path: "$[?($.x==@.child)]"},
		{name: "filter string equality, literal on the right", path: "$[?(@.child=='x')]"},
		{name: "filter string equality, literal on the left", path: "$[?('x'==@.child)]"},
		{name: "filter string equality, literal on the left with unmatched string delimiter", path: "$[?('x==@.child)]"},
		{name: "filter string equality with unmatched string delimiter", path: "$[?(@.child=='x)]"},
		{name: "filter integer inequality, literal on the right", path: "$[?(@.child!=1)]"},
		{name: "filter inequality with missing left hand operator", path: "$[?(!=1)]"},
		{name: "filter equality with missing right hand value", path: "$[?(@.child!=)]"},
		{name: "filter greater than, integer literal on the right", path: "$[?(@.child>1)]"},
		{name: "filter greater than, decimal literal on the right", path: "$[?(@.child> 1.5)]"},
		{name: "filter greater than, path to path", path: "$[?(@.child1>@.child2)]"},
		{name: "filter greater than with left hand operand missing", path: "$[?(>1)]"},
		{name: "filter greater than with missing right hand value", path: "$[?(@.child>)]"},
		{name: "filter greater than, string on the right", path: "$[?(@.child>'x')]"},
		{name: "filter greater than, string on the left", path: "$[?('x'>@.child)]"},
		{name: "filter greater than or equal, integer literal on the right", path: "$[?(@.child>=1)]"},
		{name: "filter greater than or equal, decimal literal on the right", path: "$[?(@.child>=1.5)]"},
		{name: "filter greater than or equal with left hand operand missing", path: "$[?(>=1)]"},
		{name: "filter greater than or equal with missing right hand value", path: "$[?(@.child>=)]"},
		{name: "filter greater than or equal, string on the right", path: "$[?(@.child>='x')]"},
		{name: "filter greater than or equal, string on the left", path: "$[?('x'>=@.child)]"},
		{name: "filter less than, integer literal on the right", path: "$[?(@.child<1)]"},
		{name: "filter less than, decimal literal on the right", path: "$[?(@.child< 1.5)]"},
		{name: "filter less than with left hand operand missing", path: "$[?(<1)]"},
		{name: "filter less than with missing right hand value", path: "$[?(@.child<)]"},
		{name: "filter less than, string on the right", path: "$[?(@.child<'x')]"},
		{name: "filter less than, string on the left", path: "$[?('x'<@.child)]"},
		{name: "filter less than or equal, integer literal on the right", path: "$[?(@.child<=1)]"},
		{name: "filter less than or equal, decimal literal on the right", path: "$[?(@.child<=1.5)]"},
		{name: "filter less than or equal with left hand operand missing", path: "$[?(<=1)]"},
		{name: "filter less than or equal with missing right hand value", path: "$[?(@.child<=)]"},
		{name: "filter less than or equal, string on the right", path: "$[?(@.child<='x')]"},
		{name: "filter less than or equal, string on the left", path: "$[?('x'<=@.child)]"},
		{name: "filter conjunction", path: "$[?(@.child&&@.other)]"},
		{name: "filter conjunction with literals and whitespace", path: "$[?(@.child == 'x' && -9 == @.other)]"},
		{name: "filter conjunction with bracket children", path: "$[?(@['child'][*]&&@['other'])]"},
		{name: "filter invalid leading conjunction", path: "$[?(&&"},
		{name: "filter conjunction with extra whitespace", path: "$[?(@.child && @.other)]"},
		{name: "filter disjunction", path: "$[?(@.child||@.other)]"},
		{name: "filter invalid leading disjunction", path: "$[?(||"},
		{name: "filter disjunction with extra whitespace", path: "$[?(@.child || @.other)]"},
		{name: "simple filter of child", path: "$.child[?(@.child)]"},
		{name: "filter with missing end", path: "$[?(@.child"},
		{name: "nested filter (edge case)", path: "$[?(@.y[?(@.z)])]"},
		{name: "filter negation", path: "$[?(!@.child)]"},
		{name: "filter negation of comparison (edge case)", path: "$[?(!@.child>1)]"},
		{name: "filter negation of bracket", path: "$[?(!(@.child))]"},
		{name: "filter regular expression", path: "$[?(@.child=~/.*/)]"},
		{name: "filter regular expression with escaped /", path: `$[?(@.child=~/\/.*/)]`},
		{name: "filter regular expression with escaped \\", path: `$[?(@.child=~/\\/)]`},
		{name: "filter regular expression with missing leading /", path: `$[?(@.child=~.*/)]`},
		{name: "filter regular expression with missing trailing /", path: `$[?(@.child=~/.*)]`},
		{name: "filter regular expression to match string literal", path: `$[?('x'=~/.*/)]`},
		{name: "filter regular expression to match integer literal", path: `$[?(0=~/.*/)]`},
		{name: "filter regular expression to match float literal", path: `$[?(.1=~/.*/)]`},
		{name: "filter invalid regular expression", path: `$[?(@.child=~/(.*/)]`},
		{name: "unescaped single quote in bracket child name", path: `$['single'quote']`},
		{name: "escaped single quote in bracket child name", path: `$['single\']quote']`},
		{name: "escaped backslash in bracket child name", path: `$['\\']`},
		{name: "unescaped single quote after escaped backslash in bracket child name", path: `$['single\\'quote']`},
		{name: "unsupported escape sequence in bracket child name", path: `$['\n']`},
		{name: "unclosed and empty bracket child name with space", path: `$[ '`},
		{name: "unclosed and empty bracket child name with formfeed", path: "[\f'"},
		{name: "filter involving value of current node on left hand side", path: "$[?(@==1)]"},
		{name: "filter involving value of current node on right hand side", path: "$[?(1==@ || 2== @ )]"},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r != nil {
					t.Errorf("Tokenizer panicked for path: %s\nPanic: %v", tc.path, r)
				}
			}()

			tokenizer := NewTokenizer(tc.path)
			_ = tokenizer.Tokenize()
		})
	}
}
